# Bank Tech Test

| [![Ruby Style Guide](https://img.shields.io/badge/code_style-rubocop-brightgreen.svg)](https://github.com/rubocop/rubocop) | [![Ruby Style Guide](https://img.shields.io/badge/code_style-community-brightgreen.svg)](https://rubystyle.guide) | [![Maintainability](https://api.codeclimate.com/v1/badges/c1a02154e8d14603ef2c/maintainability)](https://codeclimate.com/github/iainaitken/bank-tech-test/maintainability) |

## Tech Stack

Ruby version 2.7.2

Gems:

* Coveralls
* RSpec
* Rubocop
* SimpleCov

## Directions

### Installation

To grab the repo from github, enter the following command in your terminal window in the folder where you would like the project folder to be located:

```bash
% git clone https://github.com/iainaitken/bank-tech-test.git
```

Navigate to the project folder:

```bash
% cd bank-tech-test
```

Install dependencies:

```bash
% bundle install
```

### Testing

To run the test suite, enter the following command in the project folder:

```bash
% rspec
```

Test coverage is currently 100%.

### Usage

To use the program, first open the runfile in IRB:

```bash
% ruby -r ./lib/runfile.rb
```

In IRB, you first create a new account:

```ruby
account = BankAccount.new
```

You can deposit money to the account using the #deposit method, specifying the amount:

```ruby
account.deposit(amount: 1000)
```

You can withdraw money from the account using the #withdraw method, specifying the amount:

```ruby
account.withdraw(amount: 500)
```

Note:

* Keyword arguments are used.
* Amounts must be in the form of an integer and must be whole pounds only.
* The transaction is saved to the account with the date auto-added.

To print out a statement:

```ruby
account.print_statement
```

## Screenshot

![](./screenshots/screenshot.png)

## Specifications

### Requirements

* You should be able to interact with your code via a REPL like IRB or the JavaScript console. (You don't need to implement a command line interface that takes input from STDIN.)
* Deposits, withdrawal.
* Account statement (date, amount, balance) printing.
* Data can be kept in memory (it doesn't need to be stored to a database or anything).

### Acceptance Criteria

Given a client makes a deposit of 1000 on 10-01-2012

And a deposit of 2000 on 13-01-2012

And a withdrawal of 500 on 14-01-2012

When she prints her bank statement she would see

> date || credit || debit || balance
> 
> 14/01/2012 || || 500.00 || 2500.00
> 
> 13/01/2012 || 2000.00 || || 3000.00
> 
> 10/01/2012 || 1000.00 || || 1000.00

## Design Notes

### Initial Design

I initially decided to implement the following classes in this program:

* Transaction. This class would hold the details of an individual transaction and the resulting balance in the account. 
* BankAccount. This class would have two main responsibilities; first, it would hold all of the Transaction instances as a transaction history. It would also contain a method to let the user add a transaction to the transaction history. It also keeps track of the account balance, so that data can be easily accessed elsewhere in the program.
* TransactionValidator. This class functions as an error checker; it takes the information submitted by the user and checks that it is valid, in particular that:
  * The transaction does not result in the account becoming overdrawn.
  * The transaction type is valid, i.e. it is either "debit" or "credit".
  * The amount of the transaction is an integer.
* Statement. This class allows the user to view their transaction history.

Although BankAccount has two main responsibilities, I decided against splitting any more of it out to a different class, to avoid the program becoming too fragmented and difficult to follow. The responsibilities of that class (tracking transactions and account balance) are closely related and it didn't make sense to me to have, for example, a separate TransactionHistory class which would add a layer of complexity that isn't justified.

I decided on using an integer datatype for the amounts based on the specifications, which state that an entry of (for example) 1000 would be £1,000, and represented in the statement as 1000.00. Otherwise, I would have used integers to represent pence, to avoid difficulties in using floats to represent money - this would have meant that the input would need to be 100000 to represent £1,000. This can be easily amended if necessary to allow the user to enter both pounds and pence.

I decided that the date should be entered by the user as an argument rather than generated by the program automatically. This is because the data in the program does not persist, and would be manually entered by the user when they wanted to print out a statement.

The program was build using a TDD approach.

### Design Iteration

Following feedback from Simo, the Makers Coach, I refactored the program as follows:

* Making use of exceptions to check the validity of a transaction in TransactionValidator.check. This gave me an outcome that I didn't want (the error/stack trace appearing in IRB, not just the reason for failing the validation check) so I also experimented with rescuing the error and displaying a message instead.
* Separating out the #add_transaction method into #deposit and #withdraw.
* Dates are added automatically, rather than user-inputted.
* Cleaning up the initialize function in BankAccount, by assigning the result of adjust_balance directly to @balance.
* Account_balance is now not stored separately; the balance is taken from the last entry in the array of transactions.
* The example from the acceptance criteria is incorporated as a feature test.
* Added a test for BankAccount.print_statement.
* Move away from testing state to testing behaviour by testing output of BankAccount.print_statement rather than testing the contents of the list of transactions.

### Future Refactoring

Possible future refactoring includes:

* Reconsider use of exceptions, and rescuing them.
* Refactor Statement class to make DRYer.
* Refactor case statement in TransactionValidator class.
* Decouple Account and Statement classes by removing assumption that last entry in Statement class is the last dated entry.

### CRC Cards

#### BankAccount

| Responsibility | Collaborator |
| ----------- | --- |
| Knows balance |   |
| Knows transaction history | Transaction  |
| Add_transaction | Transaction |

#### Transaction

| Responsibility | Collaborator |
| ----------- | --- |
| Knows date |   |
| Knows type |   |
| Knows amount |  |
| Knows resulting account balance |   |

#### TransactionValidator

| Responsibility | Collaborator |
| ----------- | --- |
| Checks validity of user input | BankAccount  |

#### Statement

| Responsibility | Collaborator |
| ----------- | --- |
| Prints out a statement | BankAccount  |

## Coach comments

### Initial Feedback

> This was a really good solution for this challenge. You’ve applied SRP well, your code is very readable and clean and also shown good use of mocking. Here is my more detailed feedback:
> 
> Documentation
> 
> - Really nice README. It’s good to see details of your reasoning and assumptions. The CRC cards are also a good way to show an overview of your design.
> - It’s good that you called out that you handled edge cases as these are assumptions you are making that were not part of the original problem statement. These can also be things you can clarify with your interviewer before starting.
>
> Object-oriented design
>
> - Nice use of dependency injection!
> - You also made good use of class methods in TransactionValidator and Statement
> - You’ve nicely separated the concerns of printing statements, input validation and managing deposits and withdrawals from each other.
> - Is string the most natural return type for TransactionValidator.check given that you are checking for a binary outcome? If the issue is that you want to be able to return a message as well, you could use exceptions instead, which are the natural way to deal with unexpected things at runtime.
> - It would be nice to have separate deposit and withdraw functions so the user doesn’t have to specify the type, which they might get wrong
> - Arguably, you might not want to let the user specify the date of a transaction - what if they doctor it?
> - A neater way to adjust the balance in Transaction would be to assign the return value of adjust_balance directly to @balance in initialise. There is no need to store the “wrong” balance first.
> - You shouldn’t need to store the account balance separately. It duplicates state since you’re already storing balances in @transaction_history
>
> Testing
> - Nice use of mocking!
> - It would be good to use the example from the acceptance criteria in your feature test so that you can demonstrate that they are met exactly (including the reverse chronological order with different dates). This will require using stubbing to control the date in your tests.
> - You’re missing a test for BankAccount.print_statement in the unit test
> - Testing the contents of the list of transactions is testing state rather than behaviour. Since BankAccount.print_statement is a public method, it’s the best to test the output of that method (behaviour) rather than look at the list of transaction itself (state).

### Feedback on Second Iteration

> Thanks for addressing my comments! Great feature test and I like how you’ve managed to test behaviour everywhere insead of state. For me, this is a pass in terms of the tech test so be prepared for some nitpicking in my remaining feedback :smile: Most of my comments are finishing touches and refinements to make your code even better.
> 
> Starting with a more major comment:
> - In TransactonValidator.amount_error, what is the purpose of raising an error and then immediately rescuing it? The purpose of errors is to signal to the the caller of the method that something went wrong that the method itself can’t deal with. If you don’t rescue the error, it will interrupt normal execution and percolate up all the way to the user and the error “Please enter a valid amount” message will be shown in IRB, which is your intention, right? This way you could simplify TransactionValidator.check to be:
>
>```ruby
> def self.check(type, amount, balance)
>  case false
>  when check_amount(amount)
>    raise ValidationError.new "Please enter a valid amount"
>  when check_overdrawn(amount, balance, type)
>    raise ValidationError.new "You cannot withdraw that much ..."
>  end
>end
>```
>
> It would also simplify your code in BankAccount:
> 
> ```ruby
> def add_transaction(type, amount)
>  @validator_class.check(type, amount, account_balance) #  this line will interrupt execution and show the error message if the checks don't pass
>  create_and_store_transaction(type, amount)
> end
> ```
> 
> - the usage instructions in your README don’t reflect your latest changes
>
> Nitpicking:
> - Using a case statement to check if something is false overcomplicates things a bit. I feel like this is easier to read:
> 
> ```ruby
> def self.check(type, amount, balance)
> if !check_amount(amount)
>    raise ValidationError.new "Please enter a valid amount"
> end
> if !check_overdrawn(amount, balance, type)
>    raise ValidationError.new "You cannot withdraw that much ..."
> end
>end
>```
>
> - TransactionValidator.check_overdrawn can be simplified to:
>
> ```ruby
> def self.check_overdrawn(amount, balance, type)
>   type == (:debit) && (amount > balance)
> end
> ```
> 
> The result of a boolean expression is already a boolean, so there is no need to explicitly return false.
> - Lines 10 and 12 in your Statement class are almost the same -- is there a way to unify them and make your code DRYer?
> 
> An optional further challenge:
> 
> If you wanted to polish things even further, you could consider that right now the Statement class implicitly assumes that the transactions are added in a given order. That introduces some tight coupling between your Account and Statement classes (if something about the order in which transactions are stored in Account changed, the statement printing would also break even though it’s in a different class). What if the Statement class could assume nothing about the order of transactions but still needed to output the data in reverse chronological order?